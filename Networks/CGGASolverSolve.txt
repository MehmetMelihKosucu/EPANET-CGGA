int CGGASolver::solve(double& tstep_, int& trials, double currentTime) {
    /*
     * =========================================================================
     * ADAPTIVE CGGA SOLVER - Delayed Transition Implementation
     * =========================================================================
     *
     * KEY PRINCIPLE: Each timestep completes with ONE mode. When indicators
     * suggest a mode change, we:
     *   1. Complete the current timestep with the current mode (no redo)
     *   2. Schedule the mode change for the NEXT timestep
     *   3. Return the NEW mode's timestep so advance() uses it
     *
     * This ensures clean history data and proper timestep alignment.
     * =========================================================================
     */

    trials = 1;
    int result = HydSolver::SUCCESSFUL;

    // Integration parameters
    theta = network->option(Options::TIME_WEIGHT);
    theta = std::max(0.5, std::min(theta, 1.0));
    kappa = network->option(Options::TEMP_DISC_PARA);
    kappa = std::max(0.0, std::min(kappa, 1.0));

    double simulationEndTime = network->option(Options::TOTAL_DURATION);

    if (currentTime >= simulationEndTime - 1e-10) {
        network->msgLog << "\nSimulation reached end time";
        return HydSolver::SUCCESSFUL;
    }

	if (currentTime > 94.000) {
        int mmk = 1409;
    }

    //=========================================================================
    // STEP 1: APPLY PENDING MODE CHANGE FROM PREVIOUS TIMESTEP
    //=========================================================================

    if (pendingModeChange) {
        SolverMode oldMode = currentMode;
        currentMode = pendingMode;
        pendingModeChange = false;

        network->msgLog << "\n==================================================";
        network->msgLog << "\n  APPLYING MODE CHANGE at t=" << currentTime;
        network->msgLog << "\n  " << getModeString(oldMode) << " -> " << getModeString(currentMode);
        network->msgLog << "\n==================================================";

        // Notify history manager of mode change
        FlowHistoryManager::getInstance().notifyModeChange(
            static_cast<int>(currentMode), currentTime, network);

        // Setup WH transition if entering Water Hammer
        if (currentMode == WATER_HAMMER) {
            double whTstep = computeTimeStepForMode(WATER_HAMMER, currentTime, simulationEndTime);
            //FlowHistoryManager::getInstance().prepareForWHTransition(network, currentTime, whTstep);

            transitionState.isActive = true;
            transitionState.fromMode = oldMode;
            transitionState.toMode = WATER_HAMMER;
            transitionState.transitionTime = currentTime;
            transitionState.fromTimestep = previousTimestep;
            transitionState.toTimestep = whTstep;
            transitionState.stepsSinceTransition = 0;

            forcedWHSteps = forcedWHSteps0;
        }
        else if (currentMode == RWC) {
            // Clear WH transition state when entering RWC
            transitionState.clear();
            FlowHistoryManager::getInstance().clearTransitionStates();
            forcedRWCSteps = forcedRWCSteps0;
        }
    }

    storeTimestepInitialState(currentTime);

    //=========================================================================
    // STEP 2: INITIAL SOLVE AT t=0
    //=========================================================================

    const double initialTimeTolerance = 1e-9;
    if (currentTime < initialTimeTolerance) {
        network->msgLog << "\n==================================================";
        network->msgLog << "\n  INITIAL SOLVE at t=0";
        network->msgLog << "\n==================================================";

        currentMode = QUASI_STEADY;
        simulationPhase = FRONT_END;
        pendingModeChange = false;
        whLockedOut = false;

        // Use provided timestep for initial solve
        tstep = tstep_;

        result = executeQuasiSteadySolve(tstep, trials, currentTime);
        if (result != HydSolver::SUCCESSFUL) return result;

        maxPhiA = 0.0;
        maxPhiR = 0.0;
        previousMode = QUASI_STEADY;
        previousTimestep = tstep;

        // Return same timestep (QS continues)
        tstep_ = computeTimeStepForMode(QUASI_STEADY, currentTime + tstep, simulationEndTime);

        return result;
    }

    //=========================================================================
    // STEP 3: EVENT DETECTION
    //=========================================================================

    bool eventDetected = detectHydraulicEvent(currentTime);
    bool eventOngoing = isEventOngoing(currentTime);

    // New event clears WH lockout
    if (eventDetected && whLockedOut) {
        network->msgLog << "\n  New hydraulic event - clearing WH lockout";
        whLockedOut = false;
    }

    //=========================================================================
    // STEP 4: ENTER MIDWAY ON EVENT DETECTION
    //=========================================================================

    if ((simulationPhase == FRONT_END || simulationPhase == BACK_END) && eventDetected) {
        simulationPhase = MIDWAY;
        eventStartTime = currentTime;
        whLockedOut = false;

        network->msgLog << "\n  Event detected at t=" << currentTime << " - entering MIDWAY";

        // Start with RWC to assess the situation
        // We complete THIS timestep with RWC, then evaluate
        currentMode = RWC;
        forcedRWCSteps = forcedRWCSteps0;

        FlowHistoryManager::getInstance().notifyModeChange(1, currentTime, network);
    }

    //=========================================================================
    // STEP 5: COMPUTE TIMESTEP AND EXECUTE SOLVE FOR CURRENT MODE
    //=========================================================================

    // Compute timestep for current mode
    tstep = computeTimeStepForMode(currentMode, currentTime, simulationEndTime);

    // Track WH transition progress
    if (transitionState.isActive && currentMode == WATER_HAMMER) {
        transitionState.stepsSinceTransition++;
        double waveTimeMax = getMaxWaveTime();
        int stepsNeeded = static_cast<int>(std::ceil(2.0 * waveTimeMax / tstep)) + 5;
        if (transitionState.stepsSinceTransition > stepsNeeded) {
            transitionState.isActive = false;
            network->msgLog << "\n  WH transition complete after "
                << transitionState.stepsSinceTransition << " steps";
        }
    }

	if (currentTime > 93.000) {
        int mmk = 1409;
    }

    // Execute the solve for current mode - NO REDOS
    switch (currentMode) {
    case WATER_HAMMER:
        result = executeWaterHammerSolve(tstep, trials, currentTime);
        break;
    case RWC:
        result = executeRWCSolve(tstep, trials, currentTime);
        break;
    case QUASI_STEADY:
    default:
        result = executeQuasiSteadySolve(tstep, trials, currentTime);
        break;
    }

    if (result != HydSolver::SUCCESSFUL) return result;

    //=========================================================================
    // STEP 6: COMPUTE INDICATORS AND SCHEDULE MODE CHANGES FOR NEXT TIMESTEP
    //=========================================================================

    // Default: continue with current mode, return current timestep
    double nextTimestep = tstep;

    if (simulationPhase == MIDWAY) {

        computeFlowIndicators(currentTime, tstep);

        bool aboveDynamic = (maxPhiA > phiA_D) && (maxPhiR > phiR_D);
        bool belowDynamic = (maxPhiA < phiA_D) || (maxPhiR < phiR_D);
        bool belowInertial = (maxPhiA < phiA_I) && (maxPhiR < phiR_I);

        // -----------------------------------------------------------------
        // CURRENT MODE: WATER HAMMER
        // -----------------------------------------------------------------
        if (currentMode == WATER_HAMMER) {
            forcedWHSteps--;

            if (belowDynamic && forcedWHSteps <= 0) {
                // =========================================================
                // SCHEDULE WH -> RWC for NEXT timestep
                // This timestep is complete with WH. Don't redo!
                // =========================================================
                pendingModeChange = true;
                pendingMode = RWC;
                whLockedOut = true;

                // Return RWC timestep for next iteration
                nextTimestep = computeTimeStepForMode(RWC, currentTime + tstep, simulationEndTime);

                network->msgLog << "\n  [t=" << currentTime << "] Scheduling WH->RWC for next timestep";
                network->msgLog << "\n    Indicators: phiA=" << maxPhiA << ", phiR=" << maxPhiR;
                network->msgLog << "\n    Current step completed with WH (dt=" << tstep << ")";
                network->msgLog << "\n    Next step will use RWC (dt=" << nextTimestep << ")";
                network->msgLog << "\n    WH now LOCKED OUT";
            }
            else {
                // Continue with WH
                nextTimestep = tstep;
            }
        }
        // -----------------------------------------------------------------
        // CURRENT MODE: RWC
        // -----------------------------------------------------------------
        else if (currentMode == RWC) {
            forcedRWCSteps--;

            if (aboveDynamic && !whLockedOut) {
                // =========================================================
                // SCHEDULE RWC -> WH for NEXT timestep
                // This timestep is complete with RWC. Don't redo!
                // =========================================================
                pendingModeChange = true;
                pendingMode = WATER_HAMMER;

                // Return WH timestep for next iteration
                nextTimestep = computeTimeStepForMode(WATER_HAMMER, currentTime + tstep, simulationEndTime);

                network->msgLog << "\n  [t=" << currentTime << "] Scheduling RWC->WH for next timestep";
                network->msgLog << "\n    Indicators: phiA=" << maxPhiA << ", phiR=" << maxPhiR;
                network->msgLog << "\n    Current step completed with RWC (dt=" << tstep << ")";
                network->msgLog << "\n    Next step will use WH (dt=" << nextTimestep << ")";
            }
            else if (!eventOngoing && belowInertial && forcedRWCSteps <= 0) {
                // =========================================================
                // SCHEDULE RWC -> QS (exit MIDWAY)
                // =========================================================
                pendingModeChange = true;
                pendingMode = QUASI_STEADY;
                simulationPhase = BACK_END;

                // Return QS timestep for next iteration
                nextTimestep = computeTimeStepForMode(QUASI_STEADY, currentTime + tstep, simulationEndTime);

                network->msgLog << "\n  [t=" << currentTime << "] Scheduling RWC->QS (exiting MIDWAY)";
                network->msgLog << "\n    Next step will use QS (dt=" << nextTimestep << ")";
            }
            else {
                // Continue with RWC
                nextTimestep = tstep;

                if (aboveDynamic && whLockedOut) {
                    network->msgLog << "\n  [Lockout] Indicators high but WH locked out";
                }
            }
        }
    }
    else {
        // FRONT_END or BACK_END: continue with QS
        nextTimestep = computeTimeStepForMode(QUASI_STEADY, currentTime + tstep, simulationEndTime);
    }

    //=========================================================================
    // STEP 7: STORE STATE AND RETURN NEXT TIMESTEP
    //=========================================================================

    previousTimestep = tstep;
    previousMode = currentMode;

    // CRITICAL: Return the timestep for the NEXT iteration
    // This may be different from tstep if a mode change is pending
    tstep_ = nextTimestep;

    return result;
}

int CGGASolver::solve(double& tstep_, int& trials, double currentTime) {
    /*
     * =========================================================================
     * ADAPTIVE CGGA SOLVER - Paper-Faithful Implementation
     * =========================================================================
     *
     * CRITICAL BEHAVIOR (from Nault & Karney 2020, Figure 6):
     *
     * For RWC → WH transition:
     *   - "t = t - 1 and Δt = Δt_WH"
     *   - This means: REDO the current timestep with Water Hammer
     *   - prepareForWHTransition() interpolates history for MOC reach-back
     *
     * For WH → RWC transition:
     *   - Just continue forward (no redo needed)
     *   - WH already captured all physics correctly
     *
     * =========================================================================
     */

    trials = 1;
    int result = HydSolver::SUCCESSFUL;

    // Integration parameters
    theta = network->option(Options::TIME_WEIGHT);
    theta = std::max(0.5, std::min(theta, 1.0));
    kappa = network->option(Options::TEMP_DISC_PARA);
    kappa = std::max(0.0, std::min(kappa, 1.0));

    double simulationEndTime = network->option(Options::TOTAL_DURATION);

    // Check for simulation end
    if (currentTime >= simulationEndTime - 1e-10) {
        network->msgLog << "\nSimulation reached end time";
        return HydSolver::SUCCESSFUL;
    }

    //=========================================================================
    // STEP 1: INITIAL SOLVE AT t=0 (Front-End Simulation)
    //=========================================================================

    const double initialTimeTolerance = 1e-9;
    if (currentTime < initialTimeTolerance) {
        network->msgLog << "\n==================================================";
        network->msgLog << "\n  INITIAL SOLVE at t=0 (FRONT-END)";
        network->msgLog << "\n==================================================";

        currentMode = QUASI_STEADY;
        simulationPhase = FRONT_END;
        whLockedOut = false;
        forcedWHSteps = 0;
        forcedRWCSteps = 0;

        tstep = tstep_;
        result = executeQuasiSteadySolve(tstep, trials, currentTime);
        if (result != HydSolver::SUCCESSFUL) return result;

        // Initialize indicators
        maxPhiA = 0.0;
        maxPhiR = 0.0;
        previousMode = QUASI_STEADY;
        previousTimestep = tstep;

        // Continue with QS for next step
        tstep_ = computeTimeStepForMode(QUASI_STEADY, currentTime + tstep, simulationEndTime);
        return result;
    }

    //=========================================================================
    // STEP 2: EVENT DETECTION
    //=========================================================================

    bool eventDetected = detectHydraulicEvent(currentTime);
    bool eventOngoing = isEventOngoing(currentTime);

    // New event clears WH lockout (allows re-escalation to WH)
    if (eventDetected && whLockedOut) {
        network->msgLog << "\n  New hydraulic event detected - clearing WH lockout";
        whLockedOut = false;
    }

    //=========================================================================
    // STEP 3: ENTER MIDWAY ON EVENT DETECTION
    //=========================================================================

    // Per paper: "The first microsimulation during a midway period uses the 
    // CGGA as a water hammer model, so instantaneous, fast, and slow events 
    // do not need to be distinguished."

    if ((simulationPhase == FRONT_END || simulationPhase == BACK_END) && eventDetected) {
        simulationPhase = MIDWAY;
        eventStartTime = currentTime;
        whLockedOut = false;

        network->msgLog << "\n==================================================";
        network->msgLog << "\n  EVENT DETECTED - ENTERING MIDWAY at t=" << currentTime;
        network->msgLog << "\n==================================================";

        // Start with Water Hammer (per paper's recommendation)
        currentMode = WATER_HAMMER;
        forcedWHSteps = forcedWHSteps0;

        // Notify history manager and prepare history for WH
        FlowHistoryManager::getInstance().notifyModeChange(2, currentTime, network);

        double whTstep = computeTimeStepForMode(WATER_HAMMER, currentTime, simulationEndTime);
        FlowHistoryManager::getInstance().prepareForWHTransition(network, currentTime, whTstep);
    }

    //=========================================================================
    // STEP 4: STORE STATE BEFORE SOLVE (for potential RWC→WH rollback)
    //=========================================================================

    // These vectors store pre-solve state for "t = t - 1" redo
    std::vector<double> savedNodeHeads;
    std::vector<double> savedLinkFlows;
    std::vector<double> savedStartFlows;
    std::vector<double> savedEndFlows;

    if (currentMode == RWC && simulationPhase == MIDWAY && !whLockedOut) {
        // Save state in case we need to redo with WH
        storeNetworkState(savedNodeHeads, savedLinkFlows, savedStartFlows, savedEndFlows);
    }

    //=========================================================================
    // STEP 5: COMPUTE TIMESTEP AND EXECUTE SOLVE
    //=========================================================================

    tstep = computeTimeStepForMode(currentMode, currentTime, simulationEndTime);

    network->msgLog << "\n  [t=" << currentTime << "] Mode: " << getModeString(currentMode)
        << ", Δt=" << tstep;

    // Execute solve based on current mode
    switch (currentMode) {
    case WATER_HAMMER:
        result = executeWaterHammerSolve(tstep, trials, currentTime);
        break;
    case RWC:
        result = executeRWCSolve(tstep, trials, currentTime);
        break;
    case QUASI_STEADY:
    default:
        result = executeQuasiSteadySolve(tstep, trials, currentTime);
        break;
    }

    if (result != HydSolver::SUCCESSFUL) return result;

    //=========================================================================
    // STEP 6: COMPUTE FLOW INDICATORS
    //=========================================================================

    double nextTimestep = tstep;

    if (simulationPhase == MIDWAY) {
        // Compute φ_A and φ_R for all pipes
        computeFlowIndicators(currentTime, tstep);

        network->msgLog << "\n    Indicators: max_φA=" << maxPhiA
            << ", max_φR=" << maxPhiR;

        // Threshold comparisons
        bool aboveDynamic = (maxPhiA > phiA_D) && (maxPhiR > phiR_D);
        bool belowDynamic = (maxPhiA < phiA_D) || (maxPhiR < phiR_D);
        bool belowInertial = (maxPhiA < phiA_I) && (maxPhiR < phiR_I);

        //=====================================================================
        // STEP 7: MODE TRANSITION LOGIC (per Figure 6 of paper)
        //=====================================================================

        // -----------------------------------------------------------------
        // CURRENT MODE: WATER HAMMER
        // -----------------------------------------------------------------
        if (currentMode == WATER_HAMMER) {
            forcedWHSteps--;

            // Check for WH → RWC transition
            // Condition: (φA < φ'_AD OR φR < φ'_RD) AND f_WH ≤ 0
            if (belowDynamic && forcedWHSteps <= 0) {

                // =============================================================
                // WH → RWC: Just continue forward (no redo needed)
                // Per paper: WH already captured all physics correctly
                // =============================================================

                network->msgLog << "\n  ▼ WH → RWC transition (continuing forward)";

                currentMode = RWC;
                forcedRWCSteps = forcedRWCSteps0;
                whLockedOut = true;  // "Ratchet down" - prevent immediate return to WH

                FlowHistoryManager::getInstance().notifyModeChange(1, currentTime + tstep, network);

                nextTimestep = computeTimeStepForMode(RWC, currentTime + tstep, simulationEndTime);

                network->msgLog << "\n    WH LOCKED OUT (will use RWC until new event)";
                network->msgLog << "\n    Next Δt=" << nextTimestep;
            }
            else {
                // Continue with WH
                nextTimestep = tstep;
            }
        }
        // -----------------------------------------------------------------
        // CURRENT MODE: RWC
        // -----------------------------------------------------------------
        else if (currentMode == RWC) {
            forcedRWCSteps--;

            // Check for RWC → WH transition (escalation)
            // Condition: (φA > φ'_AD AND φR > φ'_RD) AND not locked out
            if (aboveDynamic && !whLockedOut) {

                // =============================================================
                // RWC → WH: IMPLEMENT "t = t - 1" (REDO THIS TIMESTEP)
                // =============================================================

                network->msgLog << "\n  ▲ RWC → WH transition (REDOING timestep!)";
                network->msgLog << "\n    Indicators exceeded thresholds:";
                network->msgLog << "\n      φA=" << maxPhiA << " > φ'_AD=" << phiA_D;
                network->msgLog << "\n      φR=" << maxPhiR << " > φ'_RD=" << phiR_D;

                // Step 1: Restore pre-solve state ("t = t - 1")
                restoreNetworkState(savedNodeHeads, savedLinkFlows,
                    savedStartFlows, savedEndFlows);

                network->msgLog << "\n    State restored to pre-RWC values";

                // Step 2: Change mode to Water Hammer
                currentMode = WATER_HAMMER;
                forcedWHSteps = forcedWHSteps0;

                // Step 3: Compute WH timestep
                double whTstep = computeTimeStepForMode(WATER_HAMMER, currentTime, simulationEndTime);

                // Step 4: Prepare history - LINEAR INTERPOLATION for MOC reach-back
                FlowHistoryManager::getInstance().notifyModeChange(2, currentTime, network);
                FlowHistoryManager::getInstance().prepareForWHTransition(network, currentTime, whTstep);

                network->msgLog << "\n    History interpolated for WH (Δt_WH=" << whTstep << ")";

                // Step 5: Re-solve with Water Hammer (THIS IS THE REDO)
                result = executeWaterHammerSolve(whTstep, trials, currentTime);
                if (result != HydSolver::SUCCESSFUL) return result;

                // Step 6: Recompute indicators with WH solution
                computeFlowIndicators(currentTime, whTstep);

                network->msgLog << "\n    Redo complete. New indicators: φA=" << maxPhiA
                    << ", φR=" << maxPhiR;

                tstep = whTstep;
                nextTimestep = whTstep;
            }
            // Check for RWC → QS transition (exit MIDWAY)
            // Condition: event finished AND (φA < φ'_AI AND φR < φ'_RI) AND f_RWC ≤ 0
            else if (!eventOngoing && belowInertial && forcedRWCSteps <= 0) {

                // =============================================================
                // RWC → QS: Exit MIDWAY, enter BACK-END
                // =============================================================

                network->msgLog << "\n  ▼ RWC → QS transition (exiting MIDWAY)";

                currentMode = QUASI_STEADY;
                simulationPhase = BACK_END;

                nextTimestep = computeTimeStepForMode(QUASI_STEADY, currentTime + tstep, simulationEndTime);

                network->msgLog << "\n    Entering BACK-END simulation";
                network->msgLog << "\n    Next Δt=" << nextTimestep;
            }
            else {
                // Continue with RWC
                nextTimestep = tstep;

                if (aboveDynamic && whLockedOut) {
                    network->msgLog << "\n    [LOCKOUT ACTIVE] Indicators high but WH locked out";
                    network->msgLog << "\n    Continuing with RWC until new event";
                }
            }
        }
    }
    else {
        // FRONT_END or BACK_END: continue with QS
        nextTimestep = computeTimeStepForMode(QUASI_STEADY, currentTime + tstep, simulationEndTime);
    }

    //=========================================================================
    // STEP 8: FINALIZE AND RETURN
    //=========================================================================

    previousTimestep = tstep;
    previousMode = currentMode;
    tstep_ = nextTimestep;

    return result;
}
